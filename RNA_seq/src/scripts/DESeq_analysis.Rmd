---
title: "vsp/evl double Knockout"
author: "Kristen Wells"
date: "`r format(Sys.Date(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    highlight: "tango"
    df_print: "paged"
    code_folding: "hide"
    self_contained: true
params:
  genome: "GRCm38"
  DE_alpha: 0.05
  DE_lfc: 1
  counts: "results/evl_vasp_countTable_cutadapt_trim.txt"
  fastqc_one: "results/fastqc_pre_trim_summary_untrimmed.tsv"
  fastqc_two: "results/fastqc_cutadapt_summary_trimmed.tsv"
  star_stats: "results/star_summary_cutadapt_trim.tsv"
  output_dir: "results/R_analysis"
  sample_info: "files/sample_info.csv"
  sample_column: "test_group"
  comparisons:
    value: 
      - ["naive_control",     "naive_dko"]
      - ["naive_control",     "activated_control"]
      - ["activated_control", "activated_dko"]
      - ["naive_dko",         "activated_dko"]
  genes:
    value:
      - "Evl"
      - "Vasp"
      - "Ctse"
      - "Slc1a5"
---
```{r, setup, include=FALSE}
knitr::opts_knit$set(
  root.dir =
    "/Users/wellskr/Documents/Analysis/Jordan_Jacobelli/Jacobelli_evl_vasp_K0")
```

```{r "Load packages and set options", include = F}
library(knitr)
library(cowplot)
library(tidyverse)
library(Matrix)
library(pheatmap)
library(ggrepel)
library(devtools)
library(gprofiler2)
library(viridis)
library(RColorBrewer)
library(ashr)
library(apeglm)
library(openxlsx)
library(DESeq2)
library(pathview)
library(KEGGREST)
library(org.Mm.eg.db)
library(LaCroixColoR)

# Set default chunk options
opts_chunk$set(
  message = F, 
  warning = F,
  comment = ""
)

```


```{r "Load Theme"}
source("src/scripts/functions.R")

################
# Theme colors #
################

# Colors for heatmap (from the ArchR package)
blueYellow <- c("#352A86", "#343DAE", "#0262E0", "#1389D2", "#2DB7A3",
	"#A5BE6A", "#F8BA43", "#F6DA23", "#F8FA0D")

# Colors for statistics
fastqc_colors <- c("#e31a1c", "#238443", "#ec7014")

star_colors <- c("#737373", "#8c6bb1", "#ec7014",
                 "#e31a1c", "#238443", "#225ea8")
```


## Background
This documents the analysis of the activated and naive t cells when EVO and VASP are both knocked out.

I ran into a couple of problems during batch correction. Because naive cells were never pared with activated cells, I cannot remove any potential effect from sorting the cells. Because of this, I am confident in my analysis for the comparisons between the control and dko, but I am less confident in my analysis for the comparisons between the naive and activated cells. To try to correct for potential effects of cell sorting, I focused my analysis mainly on genes that were unique to one comparison.

```{r, "Load in and set up data"}
# Load in the files
###############
# Count table #
###############
# Read in the count table
count_table <- read.table(params$counts, sep = "\t", row.names = 1, header = T)

################
# Sample table #
################

# Read in the sample table
sample_table <- read.table(params$sample_info, sep = ",", header = T,
                           row.names = 1)

# Ensure the count table and sample table are in the same order
count_table <- count_table[ , rownames(sample_table)]

########
# Star #
########

# Read in star stats
star_stats <- read.table(params$star_stats, sep = "\t", row.names = 1,
                         header = T)

# Filter for mapping % and total read counts
star_stats <- star_stats[grepl(
  "%|Uniquely mapped reads|mapped to multiple loci",
  rownames(star_stats)), ]

star_stats <- star_stats[!grepl(
  "^Mismatch|chimeric", rownames(star_stats)), ]

# Calculate median size
star_stats_median <- star_stats[grepl(
  "Uniquely mapped reads", rownames(star_stats)), ]

median_size <- median(as.numeric(
  star_stats_median["Uniquely mapped reads number", ])) / 1000000

median_rate <- median(as.numeric(str_remove(
  star_stats_median["Uniquely mapped reads %", ], "%")))

alignment_qual <- get_alignment_qual(median_rate)

# Pull out all sample names
samples <- colnames(star_stats)

# Make a column of metrics
star_stats$metric <- rownames(star_stats)

# Make into long form for ggplot
star_stats_long <- gather(star_stats, key = "Sample", value = "value",
                          all_of(samples))


# Add column for value type
star_stats_long <- star_stats_long %>%
  mutate(
    value = as.numeric(str_remove(value, "%")),
    val_type = ifelse(grepl("%", metric),
                      "pct", "int")
  )

# Pull out read counts
# Calculate median library size
read_counts <- star_stats_long %>%
  filter(grepl("mapped reads number", metric)) %>%
  mutate(value = round(value / 1000000)) %>%
  mutate(value = str_c(value, " million"))

##########
# FastQC #
##########

# Load in fastqc results
fastqc_summary_one <- read.table(params$fastqc_one, sep = "\t")

# Change the colnames
colnames(fastqc_summary_one) <- c("Result", "Test", "Sample")

# Update sample names
fastqc_summary_one$Sample <- sub("_S[0-9]*_L[0-9]*_", "",
                                 fastqc_summary_one$Sample)
fastqc_summary_one$Sample <- sub("_001.fastq.gz", "",
                                 fastqc_summary_one$Sample)

# Load in fastqc results
fastqc_summary_two <- read.table(params$fastqc_two, sep = "\t")

# Change the colnames
colnames(fastqc_summary_two) <- c("Result", "Test", "Sample")

# Update sample names
fastqc_summary_two$Sample <- sub("_S[0-9]*_L[0-9]*_", "",
                                 fastqc_summary_two$Sample)
fastqc_summary_two$Sample <- sub("_001.fastq.gz", "",
                                 fastqc_summary_two$Sample)

##############
# Set colors #
##############
sample_colors <- lacroix_palette("Pamplemousse", 6, "discrete")
sample_colors <- sample_colors[c(1,2,4,6)]

names(sample_colors) <- c("naive_control", "activated_control",
                          "naive_dko", "activated_dko")

```

# Quality Control {.tabset}

## FastQC Summary
`FastQC` was used to assess the quality of each fastq file. A summary of the results is shown below. Overall, this is okay. I generally focus most on the per tile sequence quality, the per sequence quality scores, the per base sequence quality, sequence length distribution, and the adapter content. All of your sequencing quality look good. The adapter content fails, but I trimmed the adapters before aligning.
```{r "Create fastqc summary", fig.width = 8.5, fig.height = 3}
fastqc_plot <- ggplot(data = fastqc_summary_one,
                      mapping = aes(x = Sample,
                                    y = Test,
                                    fill = Result)) +
  geom_tile(color = "white", size = 0.5) +
  scale_fill_manual(values = fastqc_colors) +
  theme_classic() +
  theme(
    legend.title = element_blank(),
    legend.text  = element_text(size = 8, color = "black"),
    axis.title   = element_blank(),
    axis.text    = element_text(size = 8, color = "black"),
    axis.text.x  = element_text(angle = 90, hjust = 1, vjust = 0.5)
  )

fastqc_plot
```

## FastQC after trimming Summary
Here I've reapeated `Fastqc` after adapter trimming. You can ignore most of it, but I wanted to include this so that you could see that the adapters were successfully removed by my trimming with `cutadapt` (the bottom row).
```{r "Create fastqc summary2", fig.width = 8.5, fig.height = 4}
fastqc_plot <- ggplot(data = fastqc_summary_two,
                      mapping = aes(x = Sample,
                                    y = Test,
                                    fill = Result)) +
  geom_tile(color = "white", size = 0.5) +
  scale_fill_manual(values = fastqc_colors) +
  theme_classic() +
  theme(
    legend.title = element_blank(),
    legend.text  = element_text(size = 8, color = "black"),
    axis.title   = element_blank(),
    axis.text    = element_text(size = 8, color = "black"),
    axis.text.x  = element_text(angle = 90, hjust = 1, vjust = 0.5)
  )

fastqc_plot
```

## Alignment Summary
Reads were aligned to the `r params$genome` genome using the `STAR` RNA-seq aligner. A summary of the results is shown below, the library size is displayed on each bar. The median library size was `r median_size` million reads and the median alignment rate was `r median_rate`. Overall, the alignment rate was **`r alignment_qual`**. 

This alignment looks quite good to me. The percent mapping is pretty consistent between samples and is quite high.The number of reads for the Naive_EvlVasp_MMW160 sample is a bit on the low side, but we will see if that seems to have much of an effect downstream.
```{r "Create alignment summary", fig.width = 8.5, fig.height = 3}

# Plot alignment stats
star_stats_long_pct <- star_stats_long %>%
  filter(val_type == "pct") %>%
  
  # Add median rates to metric label
  mutate(
    metric = str_remove(metric, "% of reads | reads %"),
    metric = str_to_sentence(metric)
  ) %>%
  arrange(value) %>%
  mutate(metric = fct_inorder(metric))
  
# Plot STAR alignment stats
star_plot <- ggplot(data = star_stats_long_pct,
                    mapping = aes(x = Sample,
                                  y = value,
                                  fill = metric)) +
  geom_bar(stat = "identity", color = "white", size = 0.5) +
  
  # Label bars with library size
  geom_text(
    data = read_counts, 
    aes(Sample, 50, label = value),
    show.legend = F,
    inherit.aes = F,
    color = "white", 
    angle = 90
  ) +
  
  scale_fill_manual(
    values = star_colors,
    guide  = guide_legend(reverse = T)
  ) +
  scale_y_continuous(labels = function(x) {str_c(x, "%")}) +
  theme_classic() +
  theme(
    legend.title = element_blank(),
    legend.text  = element_text(size = 8, color = "black"),
    axis.title   = element_blank(),
    axis.text    = element_text(size = 8, color = "black"),
    axis.text.x  = element_text(angle = 90, hjust = 1, vjust = 0.5)
  )

star_plot

```


## PCA
Principal component analysis was performed to assess similarities between samples. Here I've made many plots to look at different technical effects in your data. It appears that cells are clustering by RNA extraction date and by cell sorting rather than by type. These pose slight problems for batch correction.

First, cell sorting perfectly correlates with naive/activated. Removing this batch effect will also remove all of the interesting biological signal between naive and activated cells, so we will not be able to remove this.

Second, I can't perfectly account for extraction day because samples from the activated and naive groups were not extracted on the same day at any point. Fortunately, you did always pair a control with a dko so we can do this correction within the activated and naive cells.

A) PCA colored by extraction date
B) PCA colored by sex
C) PCA colored by Chimera
D) PCA colored by if cells were sorted
E) PCA colored by age
F) PCA colored by group

```{r "Run DESeq2 and create PCA plot", fig.width = 10, fig.height = 6}
# This makes a DESeq2 object where the count data is our count matrix and the colData is our sample data. I am currently making the design based on "group" but we can change this if necessary
sample_table$Age_Days <- factor(sample_table$Age_Days)
sample_table$RNA_extraction_date <- factor(sample_table$RNA_extraction_date)
sample_table$test_group <- factor(sample_table$test_group)
sample_table$Cells_sorted <- factor(sample_table$Cells_sorted)
sample_table$Condition <- factor(sample_table$Condition,
                                 levels = c("naive", "activated"))
sample_table$Group <- factor(sample_table$Group,
                             levels = c("control", "dko"))
sample_table$Donor_mice_ID <- factor(sample_table$Donor_mice_ID)
sample_table$Date_of_death <- factor(sample_table$Date_of_death)
dds <- DESeqDataSetFromMatrix(countData = count_table,
                              colData = sample_table,
                              design = formula(paste("~",
                                                     params$sample_column)))
# Here we get rid of all the genes that are not expressed
keep <- rowSums(counts(dds)) >= 10
dds <- dds[keep,]
dds <- DESeq(dds)
# This transforms the counts to have constant variance. This helps ensue that highly or lowly expressed genes will not contribute too much for the PCA or clustering analysis
vsd <- vst(dds, blind = F)

pc_1 <- plot_pca(vsd, group_by = "RNA_extraction_date")
pc_2 <- plot_pca(vsd, group_by = "Sex")
pc_3 <- plot_pca(vsd, group_by = "Date_of_death")
pc_4 <- plot_pca(vsd, group_by = "Cells_sorted")
pc_5 <- plot_pca(vsd, group_by = "Donor_mice_ID")
pc_6 <- plot_pca(vsd, group_by = "test_group", color_palette = sample_colors)

plot_grid(pc_1, pc_2, pc_3, pc_4, pc_5, pc_6,
          labels = c("A", "B", "C", "D", "E", "F"),
          nrow = 3, ncol = 2,
          align = "hv",
          axis = "r",
          label_y = 1,
          label_x = 1)
```

## PCA (batch corrected)
```{r "Run DESeq2 and create PCA plot batch", fig.width = 10, fig.height = 6}
dds$group_date <- factor(c(1,1,2,2,3,3,1,1,2,2,3,3))
# change the design
#design(dds) <- formula(~Date_of_death + test_group)
design(dds) <- formula(~Condition + Condition:group_date + Condition:Group)
#design(dds) <- formula(~RNA_extraction_date + Group)

dds <- DESeq(dds)
# This transforms the counts to have constant variance. This helps ensue that highly or lowly expressed genes will not contribute too much for the PCA or clustering analysis
vsd <- vst(dds, blind = F)

# Fix for plotting
mat <- assay(vsd)


mat <- limma::removeBatchEffect(mat, vsd$group_date,
                                design = model.matrix(~vsd$test_group))

assay(vsd) <- mat

pc_1 <- plot_pca(vsd, group_by = "RNA_extraction_date")
pc_2 <- plot_pca(vsd, group_by = "Sex")
pc_3 <- plot_pca(vsd, group_by = "Date_of_death")
pc_4 <- plot_pca(vsd, group_by = "Cells_sorted")
pc_5 <- plot_pca(vsd, group_by = "Donor_mice_ID")
pc_6 <- plot_pca(vsd, group_by = "test_group", color_palette = sample_colors)

plot_grid(pc_1, pc_2, pc_3, pc_4, pc_5, pc_6,
          labels = c("A", "B", "C", "D", "E", "F"),
          nrow = 3, ncol = 2,
          align = "hv",
          axis = "r",
          label_y = 1,
          label_x = 1)
```



# Differential Expression Analysis {.tabset}


```{r "Make directories", include = F}
# Create the output folders if it doesn't already exist
ifelse(!dir.exists(file.path(params$output_dir, "DE_files")),
       dir.create(file.path(params$output_dir, "DE_files")), FALSE)

ifelse(!dir.exists(file.path(params$output_dir, "images")),
       dir.create(file.path(params$output_dir, "images")), FALSE)
ifelse(!dir.exists(file.path(params$output_dir, "images", "heatmaps")),
       dir.create(file.path(params$output_dir, "images",
                            "heatmaps")), FALSE)
ifelse(!dir.exists(file.path(params$output_dir, "images", "GSE")),
       dir.create(file.path(params$output_dir, "images", "GSE")), FALSE)
ifelse(!dir.exists(file.path(params$output_dir, "GSE_files")),
       dir.create(file.path(params$output_dir, "GSE_files")), FALSE)
```

```{r "Run differential experession chunks", echo = F}
compare_contrast = FALSE
compare_name = TRUE
comparisons<- list(c("Conditionnaive.Groupdko", "naive_control",
                     "naive_dko"),
                   c("Conditionactivated.Groupdko", "activated_control",
                     "activated_dko"))
DE_chunks <- comparisons %>%
  map(~knit_expand("src/scripts/DESeq_template.Rmd"))
```

`r knit_child(text = DE_chunks)`

```{r "Run differential experession chunks two", echo = F}
compare_contrast = FALSE
compare_name = FALSE
comparisons<- list(c("naive_dko", "activated_dko", "naive_vs_activated",
                     "Conditionnaive.Groupdko",
                     "Conditionactivated.Groupdko"))
DE_chunks <- comparisons %>%
  map(~knit_expand("src/scripts/DESeq_template.Rmd"))
```

`r knit_child(text = DE_chunks)`

# Gene plots {.tabset}
Gene plots show the normalized expression of key genes across all samples. We can add in any genes that you would like to see in this format.
```{r "Make gene directories", include = F}
ifelse(!dir.exists(file.path(params$output_dir, "images", "gene_plots")),
       dir.create(file.path(params$output_dir, "images", "gene_plots")), FALSE)


```

```{r "Run gene experession chunks", echo = F}
gene_chunks <- params$genes %>%
  map(~knit_expand("src/scripts/gene_plots_template.Rmd"))
```

`r knit_child(text = gene_chunks)`

# Session Info

```{r}
sessionInfo()
```

```{r}
ifelse(!dir.exists(file.path(params$output_dir, "objs")),
       dir.create(file.path(params$output_dir, "objs")), FALSE)
saveRDS(dds, paste0(params$output_dir, "/objs/dds_obj.rda"))

saveRDS(vsd, paste0(params$output_dir, "/objs/vsd_obj.rda"))
```